<p>+++
title = “tailr — Tail Recursion Optimisation”
date = 2018-03-02T10:38:06+01:00
tags = [“tailr”, “tail-recursion”]
categories = [“Metaprogramming”]
+++</p>
<p>Believe it or not, all the bother with setting up this blog was such that I could write this post easier than I could on Wordpress. So now, let us get to some actual R programming!</p>
<div id="tail-recursion" class="section level2">
<h2>Tail recursion</h2>
<p>Recursive functions are the natural way to express iterations in a functional programming language, but in R, they can be significantly slower than loop-versions and for moderately long sequences or moderately deep trees, recursive functions will reach a limit imposted on them by the stack limit.</p>
<p>There are known solutions to these problems, as long as functions are written to be tail-recursive, meaning that the return value of a function is either a base value or another recursive call, but where we do not call recursively to then do something with the result.</p>
<p>An example of a tail-recursive function is this version of <code>factorial</code>:</p>
<pre class="r"><code>factorial &lt;- function(n, acc = 1) {
    if (n &lt;= 1) acc
    else factorial(n - 1, acc * n)
}</code></pre>
<p>In the base case, we return a value, in the recursive call, we return the value of the recursion. So, we recurse at the tail of the function, thus the name, “tail-recursive”.</p>
<p>An example of a function that is <em>not</em> tail-recursive, we have this version of <code>factorial</code>:</p>
<pre class="r"><code>factorial &lt;- function(n) {
    if (n &lt;= 1) 1
    else n * factorial(n - 1)
}</code></pre>
<p>We still recurse at the tail of the function, but it is not the very last thing we do, because <em>after</em> we get the value from the recursive call, we do something with it before we return: we multiply it with <code>n</code>.</p>
<p>The difference between the two functions is that the final value of the tail-recursive variant is the exact result of the recursive call. This is something we achieve by passing an accumulator, <code>acc</code>, along recursive calls. Instead of doing additional computations after a recursive call, we do these computations and pass them along the recursive call in the accumulator.</p>
<p>For most recursive functions, it is a simple matter to add an accumulator and then make the function tail-recursive, but it is something that you can always do. Sometimes, you just need <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation-passing style</a> programming to do it.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>The main reason we are interested in tail-recursive functions is that we can optimise them by replacing function calls with loops. Calling functions involve setting up execution frames/environments—with the overhead involved with that—and function calls require stack space, which we might run out of if we have very deep recursive calls. With loops, we just have to update local variables whenever we restart a loop.</p>
<p>For tail-recursive functions, we can always put the function body inside a loop and replace recursive calls with an update of the local variables—setting them to the parameters of the recursive call—and we have eliminated the function call overhead and issues with stack space. Well, we can <em>almost</em> always do this—since we can access the call stack programmatically in R, we cannot guarantee to get exactly the same behaviour if we do this. With some static analysis, it should be possible to determine when it is safe to do so, I think, but I haven’t looked into it.</p>
<p>In most functional programming languages, and all pure functional programming languages—where recursion is the only option for iteration—this tail-recursion optimisation is built into the language. Because of the dynamic nature of R, and the meta-programming capabilities of the language, it is less straightforward to implement this optimisation at the language level in R; at least it hasn’t been done, so someone must have decided it wasn’t worth the bother. The lack of this optimisation, however, detracts from the appeal of writing pure functional code in R. If you rely on recursion instead of loops, you get punished for it.</p>
<p>So, you are motivated to use loops instead of recursion in R, but sometimes that just leads to ugly code.</p>
</div>
<div id="a-detour-to-pattern-matching" class="section level2">
<h2>A detour to pattern matching</h2>
<p>In a chapter in my upcoming book on <a href="http://amzn.to/2FLAk4K">Domain-specific languages in R</a> I have a chapter on how to do ML- or Haskell-like pattern matching in R. The ideas from that chapter can also be found in my <a href="https://github.com/mailund/pmatch"><code>pmatch</code></a> package. Since this package works well with data structure manipulation, something that was complicated in my <a href="http://amzn.to/2F6pjK7">book on those</a>, I expect I will try to implement all those data structures using the new framework, so you can expect to hear more about that.</p>
<p>For now, though, consider a simple case: linked lists. The <code>list</code> type in R is really a vector with a pre-allocated size. Because of this, prepending to a <code>list</code> object is a linear time operation. We can implement linked lists with constant time prepending (but still linear time appending, <a href="http://amzn.to/2F6pjK7">unless we are clever</a>) like this:</p>
<pre class="r"><code>library(pmatch)
linked_list := NIL | CONS(car, cdr : linked_list)</code></pre>
<p>This code defines two “constructors” for linked lists. We can construct an empty linked list using <code>NIL</code> and we can construct a non-empty list by adding a head—by tradition called <code>car</code>—to an existing list—by tradition called <code>cdr</code>.</p>
<pre class="r"><code>lst &lt;- CONS(1, CONS(2, CONS(3, NIL)))
lst</code></pre>
<pre><code>## CONS(car = 1, cdr = CONS(car = 2, cdr = CONS(car = 3, cdr = NIL)))</code></pre>
<p>Once we have defined constructors from a type, we can match patterns against values, and e.g. recognise when a linked list is empty—equal to <code>NIL</code>—or not—matches a <code>CONS</code> pattern.</p>
<pre class="r"><code>llength &lt;- function(lst, acc = 0) {
  cases(lst,
        NIL -&gt; acc,
        CONS(car, cdr) -&gt; llength(cdr, acc + 1))
}
llength(lst)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>llrev &lt;- function(lst, acc = NIL) {
  cases(lst,
        NIL -&gt; acc,
        CONS(car, cdr) -&gt; llrev(cdr, CONS(car, acc)))
}
llrev(lst)</code></pre>
<pre><code>## CONS(car = 3, cdr = CONS(car = 2, cdr = CONS(car = 1, cdr = NIL)))</code></pre>
<p>Here, you might inject that there is little gain in pattern matching. After all, checking if a list is empty or not isn’t that complicated. And you are right about lists. But examples involving search trees might convince you of the benefits of pattern matching…</p>
<div id="search-trees" class="section level3">
<h3>Search trees</h3>
<p>Search trees are binary trees that holds values in all inner nodes and satisfy the invariant that all values in a left subtree are smaller than the value in an inner node, and all values in the right subtree are larger.</p>
<p>We can define a search tree like this:</p>
<pre class="r"><code>search_tree := E | T(left : search_tree, value, right : search_tree)</code></pre>
<p>Here, we use an empty tree, <code>E</code>, for leaves. We only store values in inner nodes, created with the constructor <code>T</code>.</p>
<pre class="r"><code>tree &lt;- T(T(E,1,E), 3, T(E,4,E))
tree</code></pre>
<pre><code>## T(left = T(left = E, value = 1, right = E), value = 3, right = T(left = E, value = 4, right = E))</code></pre>
<p>Because of the invariant, we know where values should be found if they are in a tree. We can look at the value in the root of a subtree. If it is larger than the value we are searching for, we need to search to the left. If it is smaller, we need to search to the right. Otherwise, it must be equal to the value. If we reach an empty tree in this search, then we know the value is no the tree.</p>
<pre class="r"><code>member &lt;- function(tree, x) {
  cases(tree,
        E -&gt; FALSE,
        T(left, val, right) -&gt; {
          if (x &lt; val) member(left, x)
          else if (x &gt; val) member(right, x)
          else TRUE
        })
}
member(tree, 0)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>member(tree, 1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>member(tree, 2)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>member(tree, 3)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>member(tree, 4)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Since data in R, in general, are immutable, we cannot update search trees. We can, however, create copies with updated structure, and because R implements “copy-on-write”, this is an efficient way of updating the structure of data we work on. If we insert elements into a search tree, what we will really be doing is to create a new tree that holds all the values the old tree held plus the new values. If the value is already in the old tree we do not add it again, but we will be returning a new tree. We create the new tree in a recursion.</p>
<p>Whenever we call recursively, we create a new inner node that will contain one subtree that is an exact copy of one of the subtrees from the old tree—shared with the old tree so no actual copying takes place—and one subtree that is created in the recursive insertion. The recursion goes left or right using the same logic as in the <code>member</code> function. If we find that the element is already in the tree, we terminate the recursion with the tree that contains the value. If we reach an empty tree, the element was not in the old tree, but we have found the place where it should be in the new tree, so we create an inner tree with two empty subtrees and the value.</p>
<pre class="r"><code>insert &lt;- function(tree, x) {
  cases(tree,
        E -&gt; T(E, x, E),
        T(left, val, right) -&gt;
          if (x &lt; val)
            T(insert(left, x), val, right)
          else if (x &gt; val)
            T(left, val, insert(right, x))
          else
            T(left, x, right)
        )
}

tree &lt;- E
for (i in sample(2:4))
  tree &lt;- insert(tree, i)

for (i in 1:6) {
  cat(i, &quot; : &quot;, member(tree, i), &quot;\n&quot;)
}</code></pre>
<pre><code>## 1  :  FALSE 
## 2  :  TRUE 
## 3  :  TRUE 
## 4  :  TRUE 
## 5  :  FALSE 
## 6  :  FALSE</code></pre>
<p>The worst-case time usage for both of these functions is proportional to the depth of the tree, and that can be linear in the number of elements stored in the tree. If we keep the tree balanced, though, the time is reduced to logarithmic in the size of the tree. A classical data structure for keeping search trees balanced is so-called <em>red-black</em> search trees. Implementing these using pointer or reference manipulation in languages such as C/C++ or Java can be quite challenging, but in a functional language, balancing such trees is a simple matter of transforming trees based on local structure.</p>
<p>Red-black search trees are binary search trees where each tree has a colour associated, either red or black. We can define colours using constant constructors and define a red-black search tree by extending the plain search tree:</p>
<pre class="r"><code>colour := R | B
rb_tree := E | T(col : colour, left : rb_tree, value, right : rb_tree)</code></pre>
<p>Except for including the colour in the pattern matching, the <code>member</code> function for this data structure is the same as for the plain search tree.</p>
<pre class="r"><code>member &lt;- function(tree, x) {
  cases(tree,
        E -&gt; FALSE,
        T(col, left, val, right) -&gt; {
          if (x &lt; val) member(left, x)
          else if (x &gt; val) member(right, x)
          else TRUE
        })
}

tree &lt;- T(R, E, 2, T(B, E, 5, E))
for (i in 1:6) {
  cat(i, &quot; : &quot;, member(tree, i), &quot;\n&quot;)
}</code></pre>
<pre><code>## 1  :  FALSE 
## 2  :  TRUE 
## 3  :  FALSE 
## 4  :  FALSE 
## 5  :  TRUE 
## 6  :  FALSE</code></pre>
<p>Red-black search trees are kept balanced because we enforce these two invariants:</p>
<ol style="list-style-type: decimal">
<li>No red node has a red parent.</li>
<li>Every path from the root to a leaf has the same number of black nodes.</li>
</ol>
<p>If every path from root to a leaf has the same number of black nodes, then the tree is perfectly balanced if we ignored the red nodes. Since no red node has a red parent, the longest path, when red nodes are considered, can be no longer than twice the length of the shortest path.</p>
<p>These invariants can be guaranteed by always inserting new values in red leaves, potentially invalidating the first invariant, and then rebalancing all sub-trees that invalidate this invariant, and at the end setting the root to be black. The rebalancing is done when returning from the recursive insertion calls that otherwise work as insertion in the plain search tree.</p>
<pre class="r"><code>insert_rec &lt;- function(tree, x) {
  match(tree,
        E -&gt; T(R, E, x, E),
        T(col, left, val, right) -&gt; {
          if (x &lt; val)
            balance(T(col, insert_rec(left, x), val, right))
          else if (x &gt; val)
            balance(T(col, left, val, insert_rec(right, x)))
          else
            T(col, left, x, right) # already here
        })
}
insert &lt;- function(tree, x) {
  tree &lt;- insert_rec(tree, x)
  tree$col &lt;- B
  tree
}</code></pre>
<p>The transformation rules for the <code>balance</code> function are shown in the figure below:</p>
<p><img src="http://users-cs.au.dk/mailund/RBT-transformations.png" /></p>
<p>Every time we see one of the trees around the edges, we must transform it into the tree in the middle. We can implement these transformations as simple as this:</p>
<pre class="r"><code>balance &lt;- function(tree) {
  match(tree,
        T(B,T(R,a,x,T(R,b,y,c)),z,d) -&gt; T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,T(R,T(R,a,x,b),y,c),z,d) -&gt; T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,b,y,T(R,c,z,d))) -&gt; T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,T(R,b,y,c),z,d)) -&gt; T(R,T(B,a,x,b),y,T(B,c,z,d)),
        otherwise -&gt; tree)
}</code></pre>
<p>For contrast, below is the version I presented in <a href="http://amzn.to/2F6pjK7">Functional Data-structures in R</a>):</p>
<pre class="r"><code>rbt_balance &lt;- function(colour, value, left, right) {
  if (pattern_match(a = left$left, b = left$right$left,
                    c = left$right$right, d = right,
                    x = left$value, y = left$right$value, z = value,
                    colour == BLACK, left$colour == RED, left$right$colour == RED)

      || pattern_match(a = left$left$left, b = left$left$right,
                       c = left$right, d = right,
                       x = left$left$value, y = left$value, z = value,
                       colour == BLACK, left$colour == RED, left$left$colour == RED)

      || pattern_match(a = left, b = right$left,
                       c = right$right$left, d = right$right$right,
                       x = value, y = right$value, z = right$right$value,
                       colour == BLACK, right$colour == RED, right$right$colour == RED)

      || pattern_match(a = left, b = right$left$left,
                       c = right$left$right, d = right$right,
                       x = value, y = right$left$value, z = right$value,
                       colour == BLACK, right$colour == RED, right$left$colour == RED)
  ) {

    left &lt;- red_black_tree_node(colour = BLACK, value = x, left = a, right = b)
    right &lt;- red_black_tree_node(colour = BLACK, value = z, left = c, right = d)
    red_black_tree_node(colour = RED, value = y, left, right)

  } else {
    red_black_tree_node(colour, value, left, right)
  }
}</code></pre>
<p>Even though this version also has a function for pattern matching, I think we can agree that the former version is more elegant.</p>
<p>The insertion function is not tail-recursive, so it is not a function we can readily optimise, but let me worry about that for a later time. I just described it here to motivate pattern matching approaches.</p>
</div>
</div>
<div id="making-llength-looping" class="section level2">
<h2>Making <code>llength</code> looping</h2>
<p>Let us return to the linked lists and the function for computing the length of a linked list:</p>
<pre class="r"><code>llength &lt;- function(lst, acc = 0) {
  cases(lst,
        NIL -&gt; acc,
        CONS(car, cdr) -&gt; llength(cdr, acc + 1))
}</code></pre>
<p>It is a nice and simple function that is easy to understand, but lists can get long, and then we run into problems with too deep recursions. A looping version is somewhat more complicated. An initial attempt could look like this:</p>
<pre class="r"><code>loop_llength &lt;- function(llist) {
    acc &lt;- 0
    repeat {
        cases(llist,
              NIL -&gt; return(acc),
              CONS(car, cdr) -&gt; {
                  acc &lt;- acc + 1
                  llist &lt;- cdr
              })
    }
}</code></pre>
<p>This version will not function, however, since it tries to <code>return</code> from inside a call to <code>cases</code>, and <code>return</code> only works inside the immediate scope.</p>
<p>Instead, we can use <code>callCC</code> to implement a non-local return like this:</p>
<pre class="r"><code>loop_llength &lt;- function(llist) {
    callCC(function(escape) {
        acc &lt;- 0
        repeat {
            cases(llist,
                  NIL -&gt; escape(acc),
                  CONS(car, cdr) -&gt; {
                      acc &lt;&lt;- acc + 1
                      llist &lt;&lt;- cdr
                  })
        }    
    })
}</code></pre>
<p>Notice that we have to use the <code>&lt;&lt;-</code> assignment operator here. This is for the same reason that we need a non-local return. The expression inside the call to <code>cases</code> is evaluated in a different environment than the local function environment, so to get to the actual variables we want to assign to, we need the non-local assignment operator.</p>
<p>This version of the length calculation works, but is hardly simple, and can be made even more efficient by replacing <code>cases</code> calls with a series of <code>if</code>-statements. But that is not something I want to do by hand—I want to automatically translate tail-recursive functions into looping functions.</p>
</div>
<div id="the-tailr-package" class="section level2">
<h2>The <code>tailr</code> package</h2>
<p>To alleviate the problems I have with recursion, I wrote a meta-program for automatically translating tail-recursive functions into looping versions. This program is available in the <a href="https://github.com/mailund/tailr"><code>tail</code> package</a> that you can get from either CRAN:</p>
<pre class="r"><code>install.packages(&quot;tailr&quot;)</code></pre>
<p>or from GitHub (for the development version):</p>
<pre class="r"><code># install.packages(&quot;devtools&quot;)
devtools::install_github(&quot;mailund/tailr&quot;)</code></pre>
<p>The goal of <code>tailr</code> is to automatically transform tail-recursive functions into loops or trampolines. At present, it implements the looping transformation, so it can handle simple tail-recursive functions, but will have problems with continuation-passing programming. Once I figure out how to handle that in a better way, I will write about it here.</p>
<div id="examples-using-tailr" class="section level3">
<h3>Examples using <code>tailr</code></h3>
<p>As a simple example of how <code>tailr</code> can be used, can take the classical recursive function for <code>factorial</code> and write it in a tail-recursive form using an accumulator:</p>
<pre class="r"><code>factorial &lt;- function(n, acc = 1) {
    if (n &lt;= 1) acc
    else factorial(n - 1, acc * n)
}</code></pre>
<p>We can then, automatically, translate that into a looping version:</p>
<pre class="r"><code>tr_factorial &lt;- tailr::loop_transform(factorial, byte_compile = FALSE)
tr_factorial</code></pre>
<pre><code>## function (n, acc = 1) 
## {
##     .tailr_n &lt;- n
##     .tailr_acc &lt;- acc
##     callCC(function(escape) {
##         repeat {
##             n &lt;- .tailr_n
##             acc &lt;- .tailr_acc
##             if (n &lt;= 1) 
##                 escape(acc)
##             else {
##                 .tailr_n &lt;&lt;- n - 1
##                 .tailr_acc &lt;&lt;- acc * n
##             }
##         }
##     })
## }</code></pre>
<pre class="r"><code>tr_factorial(100)</code></pre>
<pre><code>## [1] 9.332622e+157</code></pre>
<p>I have disabled byte compilation to make running time comparisons fair; by default it is enabled. For a function as simple as <code>factorial</code>, though, byte compiling will not affect the running time in any substantial amount.</p>
<p>We can compare the running time with the recursive function and a version that is written using a loop:</p>
<pre class="r"><code>loop_factorial &lt;- function(n) {
    val &lt;- 1
    while (n &gt; 1) {
        val &lt;- n * val
        n &lt;- n - 1
    }
    val
}

n &lt;- 1000
microbenchmark::microbenchmark(factorial(n), 
                                 loop_factorial(n), 
                                 tr_factorial(n))</code></pre>
<pre><code>## Unit: microseconds
##               expr     min       lq      mean    median        uq
##       factorial(n) 729.355 960.5980 1414.0912 1228.1565 1666.9430
##  loop_factorial(n)  50.300  58.1315  103.8345   60.3710   94.7685
##    tr_factorial(n) 152.936 177.7810  702.5285  220.9935  364.1510
##        max neval
##   5598.843   100
##   2640.108   100
##  43679.219   100</code></pre>
<p><img src="Factorial-running-times.png" /></p>
<p>There is <em>some</em> overhead in using the automatically translated version over the hand-written, naturally, and for a simple function such as <code>factorial</code>, it is not hard to write the loop-variant instead of the recursive function.</p>
<p>As we saw, rewriting <code>llength</code> as a looping function was a bit harder. With <code>tailr</code> we can do this automatically, however:</p>
<pre class="r"><code>tr_llength &lt;- tailr::loop_transform(llength)</code></pre>
<p>The function we generate is rather complicated</p>
<pre class="r"><code>tr_llength</code></pre>
<pre><code>## function (lst, acc = 0) 
## {
##     .tailr_lst &lt;- lst
##     .tailr_acc &lt;- acc
##     callCC(function(escape) {
##         repeat {
##             lst &lt;- .tailr_lst
##             acc &lt;- .tailr_acc
##             if (!rlang::is_null(..match_env &lt;- pmatch::test_pattern(lst, 
##                 NIL))) 
##                 with(..match_env, escape(acc))
##             else if (!rlang::is_null(..match_env &lt;- pmatch::test_pattern(lst, 
##                 CONS(car, cdr)))) 
##                 with(..match_env, {
##                   .tailr_lst &lt;&lt;- cdr
##                   .tailr_acc &lt;&lt;- acc + 1
##                 })
##         }
##     })
## }
## &lt;bytecode: 0x7ff15adbfdc0&gt;</code></pre>
<p>but, then, it is not one we want to manually inspect in any case.</p>
<p>The automatically generated function is complicated, but it actually outcompetes the hand-written loop version.</p>
<pre class="r"><code>make_llist &lt;- function(n) {
    l &lt;- NIL
    for (i in 1:n) {
        l &lt;- CONS(i, l)
    }
    l
}
test_llist &lt;- make_llist(100)
microbenchmark::microbenchmark(llength(test_llist),
                                 loop_llength(test_llist),
                                 tr_llength(test_llist))</code></pre>
<pre><code>## Unit: milliseconds
##                      expr      min       lq     mean   median       uq
##       llength(test_llist) 68.32258 75.89704 82.01587 80.08969 83.65529
##  loop_llength(test_llist) 76.04070 83.49137 89.80813 87.14157 92.16398
##    tr_llength(test_llist) 46.58339 51.30088 54.81284 53.15175 56.87924
##       max neval
##  137.5233   100
##  135.3436   100
##  102.1176   100</code></pre>
<p><img src="llength-running-time.png" /></p>
<p>It is, of course, possible to write a faster hand-written function to deal with this case, but it will be about as complicated as the automatically generated function, and you don’t really want to write that by hand.</p>
<p>As you have no doubt noticed about <code>llength</code>, it is not in fact tail-recursive, from the look of it, since the final recursion is enclosed by a call to <code>cases</code>. The function is only tail-recursive because it can be translated into one by rewriting the <code>cases</code> function call to a sequence of <code>if</code>-statements. The <code>tailr</code> package doesn’t handle <code>cases</code> from <code>pmatch</code> by knowing about this package. Instead, it has a mechanism that lets you provide re-writing rules.</p>
<p>If you set the attribute “tailr_transform” on a function, and set this attribute to a function, then that function will be called when <code>tailr</code> sees the function, before it attempts any other processing. The attribute must be a function that maps an expression to another, re-written, expression. The one for <code>cases</code> looks like this:</p>
<pre class="r"><code>tailr_transform_call &lt;- function(expr) {
    stopifnot(rlang::call_name(expr) == &quot;cases&quot;)

    args &lt;- rlang::call_args(expr)
    value &lt;- args[[1]]
    patterns &lt;- args[-1]
    eval(rlang::expr(cases_expr(!!value, !!!patterns)))
}
attr(cases, &quot;tailr_transform&quot;) &lt;- tailr_transform_call</code></pre>
<p>You can use this mechanism to support tail-recursion for non-tail-recursive functions that can be rewritten to be tail-recursive.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I wrote about continuation-passing in my <a href="http://amzn.to/2tgDtHl">Functional Programming in R</a> book, but it is an excellent topic for a post here, so expect to hear more about it later. It won’t be in this post, though.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>
